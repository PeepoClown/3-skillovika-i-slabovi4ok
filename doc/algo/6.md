## Деревья. Виды деревьев. Остовное дерево. Использование различных видов деревьев для поиска и сортировки. Сравнение различных методов поиска в массивах, деревьях, хэш-таблицах

Дерево – это нелинейная структура данных, используемая для представления иерархических связей, имеющих отношение «один ко многим».

Дерево с базовым типом Т определяется рекурсивно либо как пустая структура (пустое дерево), либо как узел типа Т с конечным числом древовидных структур этого же типа, называемых поддеревьями.

Самый верхний узел дерева называется корнем. 

Верхний узел для нижнего узла называется предком, а нижний узел для верхнего – потомком. Вершины (узлы), не имеющие потомков, называются терминальными вершинами или листьями. Нетерминальные вершины называются внутренними. 

Две вершины дерева соединяются ветвью. 

Дерево без ветвей с одной вершиной – это пустое или нулевое дерево.

Корень дерева лежит на нулевом уровне. 

Максимальный уровень какой-либо вершины дерева называется ее глубиной (от корня до узла) или высотой (от узла до максимально удаленного листа). Отсюда максимальный уровень корня равен нулю. Максимальный уровень всех вершин называется глубиной дерева.

Число непосредственных потомков у вершины (узла) дерева называется степенью вершины (узла).

Максимальная степень всех вершин является степенью дерева. Число ветвей от корня к вершине есть длина пути к этой вершине.

Каждому узлу дерева можно сопоставить имя узла и значение узла, то есть собственно данные, хранящиеся в этом узле. Причем, если значением являются разнородные данные (записи или объединения), то значением узла можно считать значение одного из полей этих данных, называемого ключом.

<b>Типы деревьев</b>:
- N-арное дерево;
- сбалансированное дерево;
- бинарное дерево;
- бинарное дерево поиска;
- дерево AVL;
- красно-чёрное дерево;
- 2-3 дерево. 
- РаНдОмИзИрОвАнНоЕ дЕрЕвО
- B/B+ дерево
- Префиксное дерево (ваще другая хуйня, https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D1%84%D0%B8%D0%BA%D1%81%D0%BD%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE)

---

Остовное дерево графа — это дерево, подграф данного графа, с тем же числом вершин, что и у исходного графа. Неформально говоря, остовное дерево получается из исходного графа удалением максимального числа рёбер, входящих в циклы, но без нарушения связности графа. Остовное дерево включает в себя все N вершин исходного графа и содержит N-1 ребро.

<b>Остовное дерево</b> — ациклический связный подграф данного связного неориентированного графа, в который входят все его вершины.

Понятие “остовный лес” неоднозначно, под ним могут понимать один из следующих подграфов:
- любой ациклический подграф, в который входят все вершины графа, но не обязательно связный;
- в несвязном графе — подграф, состоящий из объединения остовных деревьев для каждой его компоненты связности.

Остовное дерево также иногда называют покрывающим деревом, остовом или скелетом графа. 

---

Худший случай поиска – O(n) (когда дерево нихуя не балансится и, по сути, получился связный список)

Лучший случай – O(log(n)), когда дерево идеально сбалансировано

Бинарное дерево называется сбалансированным, если для любой его вершины высота правого поддерева отличается от высоты левого поддерева не более чем на единицу. 

Длина ветвей в n-вершинном сбалансированном дереве заключена между log(n) и 1,5*log(n).

Для сбалансированного дерева длина пути из корня в лист не превышает 1,44*log(n).

Для случайного дерева средняя длина пути из корня в лист составляет 1,39*log(n), но в худшем случае может оказаться равной n.

---

-	Поиск в массиве – O(n) (простой перебор)
-	Поиск в упорядоченном массиве – O(log(n)) (бинарный поиск)
-	Поиск в дереве – O(log(n))-O(n)
-	Поиск в хэш-таблице – O(1) (если заполненность не более 50%, вроде, дальше – хуже, вплоть до O(n)

В хэш-таблицах по значению ключа сразу определяется индекс элемента массива, в котором хранится информация. Хэш-функция ставит в соответствие каждому ключу ki индекс ячейки j, где расположен элемент с этим ключом, таким образом:
h(ki) = j, если j = (1, m),
где j принадлежит множеству от 1 до m, а m – размерность массива.

Массив, заполненный в порядке, определенным хеш-функцией, называется хеш-таблицей. Минимальная трудоемкость поиска в хеш-таблице равна О(1)

Принято считать, что хорошей является такая функция, которая удовлетворяет следующим условиям:
-	функция должна быть простой с вычислительной точки зрения;
-	функция должна распределять ключи в хеш-таблице наиболее равномерно.

Итак, первое свойство хорошей хеш-функции зависит от характеристик компьютера, а второе – от значений данных. 
Если бы все данные были случайными, то хеш-функции были бы очень простые (несколько битов ключа, например). 
Однако на практике случайные данные встречаются крайне редко, и приходится создавать функцию, которая зависела бы от всего ключа.

Может возникнуть ситуация, когда разным ключам соответствует одно значение хеш-функции, то есть, когда h(K1) = h(K2), в то время как K1 ≠ K2. 
Такая ситуация называется <b>коллизией</b>. 
В этом случае, очевидно, необходимо найти новое место для хранения ключей, претендующих на одну и ту же ячейку хеш-таблицы. 
Причем количество коллизий необходимо минимизировать. Таким образом, хорошая хеш-функция должна удовлетворять еще одному требованию, а именно: она должна минимизировать число коллизий.

---

Существует два основных типа хеширования, один из которых основан на делении, а другой на умножении. 
Впрочем, это не единственные методы, которые существуют, более того, они не всегда являются оптимальными.

Если ключей меньше, чем элементов массива, то в качестве хеш-функции можно принять вычисление остатка от деления целочисленного ключа на размерность массива (m), 
то есть:
> h(ki) = (ki mod m), при n < m, где  n – количество ключей.

Данная функция очень проста, хотя и не самая лучшая. Вообще, можно использовать любую размерность (константу m), но она должна быть такой, 
чтобы минимизировать число коллизий. 

Для этого лучше использовать простое число. В большинстве случаев подобный выбор вполне удовлетворителен. 

Для символьной строки ключом может являться остаток от деления, например, суммы кодов символов строки на m.

На практике, метод деления – самый распространенный

---

Существует несколько возможных вариантов разрешения коллизий, которые имеют свои достоинства и недостатки.

Первый метод – внешнее (открытое) хеширование (метод цепочек)

В случае, когда элемент таблицы с индексом, который вернула хеш-функция, уже занят, к нему присоединяется связный список. Таким образом, если для нескольких различных значений ключа возвращается одинаковое значение хеш-функции, то по этому адресу находится указатель на связанный список, который содержит все значения. Поиск в этом списке осуществляется простым перебором, так как при грамотном выборе хеш-функции любой из списков оказывается достаточно коротким.

Другой путь решения проблемы, связанной с коллизиями – внутреннее (закрытое) хеширование (открытая адресация). 

Оно состоит в том, чтобы полностью отказаться от ссылок. 
В этом случае, если ячейка с вычисленным индексом занята, то можно просто просматривать следующие записи таблицы по порядку (с шагом 1), до тех пор, 
пока не будет найден ключ K или пустая позиция в таблице. 

При этом, если индекс следующего просматриваемого элемента определяется добавлением какого-то постоянного шага (от 1 до n), 
то данный способ разрешения коллизий называется линейной адресацией. 

Для вычисления шага можно также применить формулу:
> h = h + a2, где a – это номер попытки поиска ключа. 

Этот вид адресации называется квадратичной или произвольной адресацией.

При любом методе разрешения коллизий необходимо ограничить длину поиска элемента. 

Если для поиска элемента необходимо более 3–4 сравнений, то эффективность использования такой хеш-таблицы пропадает и ее следует реструктуризировать 
(т.е. найти другую хеш-функцию), чтобы минимизировать количество сравнений для поиска элемента

(взято с Бомонки, http://wwwcdl.bmstu.ru/iu7/book1/stage8.htm)
