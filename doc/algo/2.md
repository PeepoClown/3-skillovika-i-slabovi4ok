## Понятие рекурсии. Рекурсивные типы данных. Рекурсивные процедуры и функции. Критерии выбора для разработки рекурсивных или итеративных алгоритмов.

Рекурсия — это такой способ организации вспомогательного алгоритма (подпрограммы), при котором эта подпрограмма (процедура или функция) 
в ходе выполнения ее операторов обращается сама к себе. 

Рекурсивные типы данных – это типы, которые содержат сами себя.
Пример - связанный список, который называется Cons.
Самый простой список из возможных - пустой, который мы называем Nil.
Непустой список – это Cons, который состоит из:
- первое значение в списке, которое мы называем head
- ссылка на остальную часть списка, которую мы называем tail
tail является рекурсивной частью: непустой список содержит меньший список, который может быть пустым или непустым.
List = Cons(3, Cons(2, Cons(1, Nil)))


Рекурсивный алгоритм всегда можно преобразовать в итеративный, использующий циклические конструкции. 
Рекурсивный подход обычно предпочитается итеративному в тех случаях, когда рекурсия более естественно отражает математическую сторону задачи и (или) приводит к 
алгоритму, который проще для понимания.

Наличие рекурсии при компьютерной реализации алгоритмов требует наличия некоторой памяти — стека вызова. 
В нем хранятся данные о дочерних рекурсивных вызовах, которые используются для возврата управления в родительскую процедуру или функцию.

Процесс разработки рекурсивных алгоритмов состоит из трех этапов: параметризации, выделении базы и декомпозиции.

Параметризация. 
На этом этапе происходит выделение параметров, описывающих входные данные алгоритма. 
Например, для вычисления F(m) — число m. Для алгоритма поиска минимального элемента во множестве чисел — количество чисел.

Выделение базы предполагает описание тривиальных случаев, для которых результат очевиден и не требует дополнительных операций. 
Рекурсивный алгоритм в конечном итоге сводится именно к этим случаям. 
Для рекурсивного вычисления факториала базовым случаем является 0! = 1, для вычисления чисел Фибоначчи — два базовых случая: F0 = 0 и F1 = 1. 

Декомпозиция. 
На этом этане рассматривается общий случай выполнения алгоритма, который сводится к выполнению более «простого» случая. 
Под «простотой» может пониматься снижение значения параметров рекурсивного алгоритма, уменьшение размерности данных и т.п.

При оценке эффективности алгоритмов, содержащих рекурсию, вычисляют следующие характеристики:

- глубину рекурсии — максимальное количество вызовов рекурсивного алгоритма без возвратов;
- текущий уровень рекурсии — количество рекурсивных вызовов в некоторый момент времени;
- общее количество вызовов — число вызовов рекурсивного алгоритма при работе программы.

Хвостовая рекурсия — частный случай рекурсии, при котором любой рекурсивный вызов является последней операцией перед возвратом из функции.
Подобный вид рекурсии примечателен тем, что может быть легко заменён на итерацию путём формальной и гарантированно корректной перестройки кода функции. 
Оптимизация хвостовой рекурсии путём преобразования её в плоскую итерацию реализована во многих оптимизирующих компиляторах. 
В некоторых функциональных языках программирования спецификация гарантирует обязательную оптимизацию хвостовой рекурсии.

В традиционной рекурсии типичная модель состоит в том, что вы сначала выполняете свои рекурсивные вызовы, 
а затем берете возвращаемое значение рекурсивного вызова и вычисляете результат. 
Таким образом, вы не получите результат своих расчетов, пока не вернетесь после каждого рекурсивного вызова.
В хвостовой рекурсии вы сначала выполняете вычисления, а затем выполняете рекурсивный вызов, 
передавая результаты текущего шага следующему рекурсивному шагу. 
Это приводит к тому, что последнее утверждение имеет вид (return (recursive-function params)). 
По сути, возвращаемое значение любого заданного рекурсивного шага совпадает с возвращаемым значением следующего рекурсивного вызова.

Следствием этого является то, что когда вы будете готовы выполнить следующий рекурсивный шаг, 
вам больше не нужен текущий фрейм стека. Это приводит к некоторой оптимизации. 
Фактически, с соответствующим образом написанным компилятором у вас никогда не должно быть перехватчика с хвостовым рекурсивным вызовом. 
Просто используйте текущий кадр стека для следующего рекурсивного шага.
